var Automato = Automato || {};
/**
  * Representa um AF (Autômato Finito)
  * @constructor
  * @param {string} JSON - O json que será utilizado para criar o AF.
  */
Automato.AFBase = function (JSON) {
    if (arguments.length == 0) return;

    this._json = JSON;
    this._nos = null;
    this._alfabeto = null;
    this._init = function () {
        // converte o json em nós
        this._nos = eval(this._json).sort(function (a, b) {
            if (a.o < b.o) {
                return -1;
            }
            if (a.o > b.o) {
                return 1;
            }
            return 0;
        }).map(function (no) {
            var transicoes = (no.t ? no.t : []).map(function (t) {
                return new Automato.Transicao(t.s, t.d);
            });
            return new Automato.No(no.o, no.r, no.f, transicoes)
        });

        // define o alfabeto que é reconhecido
        this._alfabeto = [];
        for (var i = 0; i < this._nos.length; ++i) {
            var transicoes = this._nos[i].getTransicoes();
            for (var j = 0; j < transicoes.length; ++j) {
                var simbolosDaTransicao = transicoes[j].getSimbolos();
                for (var k = 0; k < simbolosDaTransicao.length; ++k) {
                    if (!this._alfabeto.some(function (x) {
                        return x.toString() == simbolosDaTransicao[k].toString();
                    })) {
                        this._alfabeto.push(simbolosDaTransicao[k]);
                    }
                }
            }
        }
    };

    /**
      * Retorna todos os nós do AF criado.
      */
    this.getNos = function getNos() {
        return this._nos;
    };

    /**
      * Retorna o alfabeto reconhecido pelo AF criado.
      */
    this.getAlfabeto = function getAlfabeto() {
        return this._alfabeto;
    };

    /**
      * Retorna um Boolean indicando se todos os símbolos da palavra informada possuem pelo menos uma transição dentro do AF.
      * @param {string} palavra - Palavra que será verificada.
      * @returns {Boolean} Retorna 'true' se todos os símbolos da palavra possuírem pelo menos uma transição dentro do AF, 'false' caso contrário.
      */
    this.isPalavraValida = function isPalavraValida(palavra) {
        for (var i = 0; i < palavra.length; ++i) {
            if (!this._alfabeto.some(function (x) {
                return x.toString() == palavra[i].toString();
            })) {
                return {
                    resultado: Automato.MotivosRejeicao.NAO_FAZ_PARTE_DO_ALFABETO,
                    simbolo: palavra[i]
                };
            }
        }
        return true;
    }

    /**
      * Retorna um Boolean indicando se todos os símbolos da palavra informada possuem pelo menos uma transição dentro do AF.
      * @param {string} palavra - Palavra que será verificada.
      * @returns {Boolean} Retorna 'true' se todos os símbolos da palavra possuírem pelo menos uma transição dentro do AF, 'false' caso contrário.
      */
    this.getNomeNo = function getNomeNo(no) {
        return no.toString();
    }

    /**
      * Testa a palavra informada no AF gerado.
      * @param {string} Palavra que será testada no AF
      * @returns {Object} Retorna Automato.MotivosRejeicao.ACEITO se a palavra for aceita pelo AF, 
      *                   ou um objeto indicando qual o motivo da rejeição.
      */
    this.testarPalavra = function testarPalavra(palavra) { throw Automato.Mensagens.METODO_NAO_IMPLEMENTADO; }

    this._init();
}
var Automato = Automato || {};
/**
  * Representa o renderizador do grafo de um autômato
  * @constructor
  * @param {AFD} afd - O autômato que será utilizado para renderizar.
  * @param {HTMLElement} el - O elemento onde o grafo será renderizado.
  * @param {Object} settings - As configurações do sigma.js. Se nada for passado usa configurações padrão.
  */
Automato.RendererBase = function (afd, el) {
    if (arguments.length == 0) return;

    this._afd = afd;
    this._el = el;

    this.render = function () { throw Automato.Mensagens.METODO_NAO_IMPLEMENTADO; };
}
var Automato = Automato || {};
/**
  * Representa os estados de validação do autômato.
  */
Automato.Mensagens = {
    METODO_NAO_IMPLEMENTADO: "Método não implementado."
};
var Automato = Automato || {};
/**
  * Representa os estados de validação do autômato.
  */
Automato.MotivosRejeicao = {
    ACEITO: 0,
    NAO_FAZ_PARTE_DO_ALFABETO: 1,
    TRANSICAO_INEXISTENTE: 2,
    ESTADO_NAO_FINAL: 3
};
var Automato = Automato || {};
/**
  * Representa as transições que um determinado nó pode processar.
  * @constructor
  * @param {Array} simbolos - Um array de {Char} representando todos os símbolos que essa transição reconhece.
  * @param {int} destino - Representa a ordem do nó para onde essa transição levará.
  */
Automato.Transicao = function (simbolos, destino) {
    var _simbolos = simbolos;
    var _destino = destino;

    /**
      * Retorna todos os símbolos reconhecidos por essa transição.
      */
    this.getSimbolos = function getSimbolos() {
        return _simbolos;
    }

    this.getDestino = function getDestino() {
        return _destino;
    }
}
var Automato = Automato || {};
/**
  * Representa um nó de um autômato
  * @constructor
  * @param {int} ordem - Um identificador único para o nó.
  * @param {string} rotulo - O nome que será dado ao nó, caso nenhum nome seja dado será usado q{ordem}.
  * @param {Boolean} final - Valor indicando se o nó representa um estado final ou não.
  * @param {Array} transicoes - Um array de {Transicao} contendo todas as transições reconhecidas por este nó.
  */
Automato.No = function (ordem, rotulo, final, transicoes) {
    var _ordem = ordem;
    var _rotulo = rotulo;
    var _final = final;
    var _transicoes = transicoes;

    this.getFinal = function getFinal() {
        return _final;
    };

    this.getRotulo = function getRotulo() {
        return _rotulo;
    };

    /**
      * Retorna todas as transições desse nó.
      */
    this.getTransicoes = function getTransicoes() {
        return _transicoes;
    };

    /**
      * Retorna o nome do nó (que é o rótulo caso ele possua um, ou q{Ordem} caso contrário).
      */
    this.toString = function toString() {
        return _rotulo ? _rotulo.toString() : "q" + _ordem.toString();
    };
}
var Automato = Automato || {};
/**
  * Representa um AFD (Autômato Finito Determinístico)
  * @constructor
  * @param {string} JSON - O json que será utilizado para criar o AFD.
  */
Automato.AFD = function (JSON) {
    /**
      * Invoca o construtor base
      */
    Automato.AFBase.call(this, JSON);

    /**
      * Testa a palavra informada no AFD gerado.
      * @param {string} Palavra que será testada no AFD
      * @returns {Object} Retorna Automato.MotivosRejeicao.ACEITO se a palavra for aceita pelo AFD, 
      *                   ou um objeto indicando qual o motivo da rejeição.
      */
    this.testarPalavra = function testarPalavra(palavra) {
        // por ora vamos assumir que o AFD aceita a palavra vazia
        if (!palavra || palavra.length <= 0)
            return Automato.MotivosRejeicao.ACEITO;

        // verifica se o AFD aceita todos os símbolos da palavra informada
        var isValida = this.isPalavraValida(palavra);

        if (isValida !== true)
            return isValida;

        // testa a palavra
        var no = this._nos[0];
        var processados = [];
        for (var i = 0; i < palavra.length; ++i) {
            var proximo = null;
            processados.push(palavra[i]);
            var transicoes = no.getTransicoes();
            var tLength = transicoes.length;

            if (tLength > 0) {
                for (var j = 0; j < tLength; ++j) {
                    var transicao = transicoes[j];
                    var simbolos = transicao.getSimbolos();
                    if (simbolos.some(function (x) {
                        return x.toString() == palavra[i].toString();
                    })) {
                        proximo = this._nos[parseInt(transicao.getDestino())];
                    }
                }
            }

            if (proximo != null) {
                no = proximo;
            } else {
                return {
                    resultado: Automato.MotivosRejeicao.TRANSICAO_INEXISTENTE,
                    no: no,
                    processados: processados,
                    simbolo: palavra[i]
                };
            }
        }

        if (proximo == null || !proximo.getFinal()) {
            return {
                resultado: Automato.MotivosRejeicao.ESTADO_NAO_FINAL,
                proximo: proximo
            };
        }

        return Automato.MotivosRejeicao.ACEITO;
    }
}
var Automato = Automato || {};
/**
  * Representa um AFND (Autômato Finito Não Determinístico)
  * @constructor
  * @param {string} JSON - O json que será utilizado para criar o AFND.
  */
Automato.AFND = function (JSON) {
    /**
      * Invoca o construtor base
      */
    Automato.AFBase.call(this, JSON);

    /**
      * Testa a palavra informada no AFND gerado.
      * @param {string} Palavra que será testada no AFND
      * @returns {Object} Retorna Automato.MotivosRejeicao.ACEITO se a palavra for aceita pelo AFND, 
      *                   ou um objeto indicando qual o motivo da rejeição.
      */
    this.testarPalavra = function testarPalavra(palavra) {
        // por ora vamos assumir que o AFND aceita a palavra vazia
        if (!palavra || palavra.length <= 0)
            return Automato.MotivosRejeicao.ACEITO;

        // verifica se o AFND aceita todos os símbolos da palavra informada
        var isValida = this.isPalavraValida(palavra);

        if (isValida !== true)
            return isValida;

        // testa a palavra
        var no = [this._nos[0]];
        var processados = [];
        for (var i = 0; i < palavra.length; ++i) {
            var proximo = [];
            processados.push(palavra[i]);
            var transicoes = no.map(function(n){return n.getTransicoes()});
            var tLength = transicoes.length;

            if (tLength > 0) {
                for (var j = 0; j < tLength; ++j) {
                    var transicao = transicoes[j];
                    var simbolos = transicao.map(function(s){return s.getSimbolos()});
                    if (simbolos.some(function (x) {
                        return x.some(function (p) {
                            return p.toString() == palavra[i].toString();
                        });
                    })) {
                        proximo.push(this._nos[parseInt(transicao.map(function(d){return d.getDestino();}))]);
                    }
                }
            }

            if (proximo != null && proximo.length > 0) {
                no = proximo;
            } else {
                return {
                    resultado: Automato.MotivosRejeicao.TRANSICAO_INEXISTENTE,
                    no: no,
                    processados: processados,
                    simbolo: palavra[i]
                };
            }
        }

        if (proximo == null || !proximo.some(function (p) { return p.getFinal(); })) {
            return {
                resultado: Automato.MotivosRejeicao.ESTADO_NAO_FINAL,
                proximo: proximo
            };
        }

        return Automato.MotivosRejeicao.ACEITO;
    }
}
var Automato = Automato || {};
Automato.AFD = Automato.AFD || {};
Automato.AFD.Renderer = Automato.AFD.Renderer || {};
/**
  * Representa o renderizador do grafo de um autômato
  * @constructor
  * @param {AFD} afd - O autômato que será utilizado para renderizar.
  * @param {HTMLElement} el - O elemento onde o grafo será renderizado.
  * @param {Object} settings - As configurações do sigma.js. Se nada for passado usa configurações padrão.
  */
Automato.AFD.Renderer.Default = function (afd, el, settings) {
    /**
      * Invoca o construtor base
      */
    Automato.RendererBase.call(this, afd, el);

    var _nodeColor = "#CCC";
    var _finalNodeColor = "#F00";
    var _edgeColor = "#000";
    var _labelColor = "#000";
    var _sigma = null;
    var _settings = settings || {
        maxEdgeSize: 1,
        minArrowSize: 10,
        maxNodeSize: 10,
        labelThreshold: 0,
        labelSize: "proportional",
        labelSizeRatio: 1.5,
        defaultLabelColor: _labelColor,
        labelAlignment: "inside"
    };

    this.init = function() {
        _sigma = new sigma({
            renderer: {
                container: this._el,
                type: 'canvas'
            },
            settings: _settings
        });

        _sigma.graph.addNode({
            id: 'n-',
            x: 0.3,
            y: 0,
            size: 0,
            color: "#FFF"
        });
    }

    this.render = function() {
        var counter = 1;

        var nos = this._afd.getNos();
        var nLength = this._afd.getNos().length;

        var linhas = Math.round(Math.sqrt(nLength));
        var maiorNumeroColunas = Math.round(Math.pow(2, linhas - 1));

        for (var i = 0; i < nLength; ++i) {
            var linha = Math.round(Math.sqrt(i));
            var maxColunas = Math.round(Math.pow(2, linha - 1));

            var subIndice = i - linha;

            var node = this._afd.getNos()[i];

            var color = node.getFinal() ? _finalNodeColor : _nodeColor;
            var label = node.getRotulo();

            _sigma.graph.addNode({
                id: 'n' + i.toString(),
                label: label,
                x: (maiorNumeroColunas / (maxColunas + 1)) + subIndice / 2,
                y: linha,
                size: 1,
                color: color
            });

            counter += 0.4;
        }

        _sigma.graph.addEdge({
            id: 'en-',
            source: 'n-',
            target: 'n0',
            color: "#CCC",
            type: 'arrow',
            count: 0
        })

        for (var i = 0; i < nLength; ++i) {
            var node = nos[i];

            var transicoes = node.getTransicoes();
            var tLength = transicoes.length;
            if (tLength > 0) {
                for (j = 0; j < tLength; ++j) {
                    var t = transicoes[j];

                    var arrowType = i == t.getDestino() || t.getDestino() < i ? 'curvedArrow' : 'arrow';

                    _sigma.graph.addEdge({
                        id: 'en' + i.toString() + 'n' + t.getDestino().toString(),
                        // Reference extremities:
                        source: 'n' + i.toString(),
                        target: 'n' + t.getDestino().toString(),
                        label: '{' + t.getSimbolos().join(',') + '}',
                        color: _edgeColor,
                        type: arrowType,
                        count: j
                    });
                }
            }
        }
        _sigma.refresh();
    };

    this.init();
}